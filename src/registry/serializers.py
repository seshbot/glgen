import json
import time
import sys

#
# json routines
#

PROJECT_NAME = 'glgen'
PROJECT_REPO = 'https://github.com/seshbot/glgen'

JSON_PRELUDE = """\
// This file was autogenerated by %s (%s) on %s
// Command line: %s
""" % (PROJECT_NAME, PROJECT_REPO, time.strftime('%Y-%m-%d'), ' '.join(sys.argv))

def writePreludeToFile(fp):
  fp.write(JSON_PRELUDE)

def writeJson(entities, fp):
  fp.write("[\n")
  for entity in entities:
    data = entity.toDictionary()
    #json.dump(data, fp, indent=2, separators=(',', ': '))
    json.dump(data, fp)
    fp.write(',\n')
  fp.write("]")


#
# C++ routines
#

# template patterns:
#  ${DATE} - generation date
#  ${HEADER_GUARD} - to be used in header guard
#  ${CONTENTS} - entire contents of the file
HEADER_TEMPLATE = """\
/**
 * This file was autogenerated by ${PROJECT_NAME} (${PROJECT_REPO}) on ${TIME}
 * Command line: ${COMMANDLINE}
 */

#ifndef ${HEADER_GUARD}
#define ${HEADER_GUARD}

{{'\\n'.join(['#include <%s>' % h for h in SYSTEM_HEADERS]) if 'SYSTEM_HEADERS' in locals() else ''}}
{{'\\n'.join(['#include "%s"' % h for h in LOCAL_HEADERS]) if 'LOCAL_HEADERS' in locals() else ''}}

{{'\\n'.join('namespace %s {' % n for n in namespaces)}}
${CONTENT}
{{'\\n'.join('} // namespace %s' % n for n in reversed(namespaces))}}

#endif // #ifndef ${HEADER_GUARD}
"""

CPP_TEMPLATE = """\
/**
 * This file was autogenerated by ${PROJECT_NAME} (${PROJECT_REPO}) on ${TIME}
 * Command line: ${COMMANDLINE}
 */

{{'\\n'.join(['#include <%s>' % h for h in SYSTEM_HEADERS]) if 'SYSTEM_HEADERS' in locals() else ''}}
{{'\\n'.join(['#include "%s"' % h for h in LOCAL_HEADERS]) if 'LOCAL_HEADERS' in locals() else ''}}

{{'\\n'.join('namespace %s {' % n for n in namespaces)}}
${CONTENT}
{{'\\n'.join('} // namespace %s' % n for n in reversed(namespaces))}}
"""

ENUM_CLASS_TEMPLATE = """\
  enum class ${NAME} : unsigned int {
${CONTENT}  };
"""

BITMASK_ENUM_CLASS_TEMPLATE = """\
  enum class ${NAME} : unsigned int {
${CONTENT}  };
  CREATE_ENUM_BITMASK_TYPE(${MASKTYPE_NAME}, ${NAME})
"""


ENUM_VALUE_TEMPLATE = """\
    ${NAME} = ${VALUE},
"""

COMMAND_PARAMETER_TEMPLATE = "${TYPE} ${NAME}"
COMMAND_PROTOTYPE_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST});
"""


EXT_COMMAND_PROTOTYPE_TEMPLATE = """\
   /**
    * Required by extensions:
{{'\\n'.join(['    *  - %s (%s)' % (e.name, ','.join(sorted(map(lambda api: api.name, e.apis)))) for e in REQUIRED_EXTENSIONS])}}
    */
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST});
"""

COMMAND_IMPLEMENTATION_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST}) {
      ${MAYBE_RETURN}${STATIC_CAST_BEGIN}${GL_NAME}(${ARGUMENT_LIST})${STATIC_CAST_END};
    }
"""

EXT_COMMAND_IMPLEMENTATION_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST}) {
      if ( {{' || '.join(['GLAD_' + e.name for e in REQUIRED_EXTENSIONS])}} ) {
        ${MAYBE_RETURN}${STATIC_CAST_BEGIN}${GL_NAME}(${ARGUMENT_LIST})${STATIC_CAST_END};
      }
      else {
        throw std::runtime_error("OpenGL command '${GL_NAME}' not available on this platform (extensions: {{', '.join([e.name for e in REQUIRED_EXTENSIONS])}})");
      }
    }
"""


GET_CORE_PROC_ADDRESS_DECLARATION_TEMPLATE = """\
    // some extension managers use a 'getProcAddress()' function to load core functions 
    // although getProcAddress() functions are only meant to be used to load extensions.
    gl::gl_proc get_core_proc_address(const char* proc_name);

    // ANGLE's eglGetProcAddress() only returns pointers to extension functions, this function
    // behaves the way GLAD would expect it to
    gl::gl_proc get_proc_address(get_gl_proc_func get_extension_proc, const char* proc_name);

    bool is_core_proc(const char* proc_name);

"""

GET_CORE_PROC_ADDRESS_DEFINITION_TEMPLATE = """\
  namespace {
     struct proc_name_address_t {
        const char * name;
        gl::gl_proc address;
     };

     gl::gl_proc get_proc_address_impl(const char* proc_name) {
        static const proc_name_address_t proc_info[] = {
          {{'\\n          '.join(['{ "%s", reinterpret_cast<gl::gl_proc>(%s) },' % (c.name, c.name) for c in commands])}}
        };

        for (auto & inf : proc_info) {
          if (strcmp(proc_name, inf.name) == 0)
            return inf.address;
        }
        
        return nullptr;
     }
  }

  gl::gl_proc get_core_proc_address(const char* proc_name) {
    return get_proc_address_impl(proc_name);
  }

  gl::gl_proc get_proc_address(get_gl_proc_func get_extension_proc, const char* proc_name) {
    if (is_core_proc(proc_name)) return get_core_proc_address(proc_name);
    return get_extension_proc(proc_name);
  }

  bool is_core_proc(const char* proc_name) {
    return nullptr != get_proc_address_impl(proc_name);
  }

"""

import re

def compileTemplate(template, vars):
  vars['time'] = time.strftime('%Y-%m-%d')
  vars['commandline'] = ' '.join(sys.argv)
  vars['PROJECT_NAME'] = PROJECT_NAME
  vars['PROJECT_REPO'] = PROJECT_REPO
  compiled = template

  # match {{.*}} and capture expression
  eval_expr_pattern = re.compile('{{(.*?)}}', re.IGNORECASE)

  def evalExpression(match):
    expr = match.group(1)
    return eval(expr, {}, vars)

  compiled = eval_expr_pattern.sub(evalExpression, compiled)

  # match '${.*}' and capture variable name
  subst_var_pattern = re.compile('\${(.*?)}', re.IGNORECASE)
  lowervars = {name.lower(): val for name, val in vars.iteritems()}

  def substituteVar(match):
    var = match.group(1).lower()
    return lowervars[var] if var in lowervars else match.group()

  return subst_var_pattern.sub(substituteVar, compiled)

#
# name conversion utilities
#

_CAMEL_CASE_TO_SNAKE_CASE_REGEX_ = re.compile('((?<=[a-z])[A-Z0-9]|(?!^)[A-Z](?=[a-z]))')
_TYPE_NAME_REGEX_ = re.compile('(const[ ]+)?([^ *]+)([ ]*\*)?') # (const )(typename)( *)

def toTypeName(v):
  exceptions = {'void'} # do not modify these types

  prevTypename = _TYPE_NAME_REGEX_.match(v).group(2)
  newTypename = prevTypename[2:] if prevTypename.startswith('GL') else prevTypename
  newTypename = 'gl::%s_t' % newTypename if newTypename not in exceptions else newTypename
  return v.replace(prevTypename, newTypename)

def getGroupEnumName(group):
  enumname = _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', group.name).lower() + '_t'
  if group.isBitmask:
    return re.sub('(_mask)?_t$', '_flags_t', enumname)
  return enumname

def getGroupMasktypeName(group):
  enumname = _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', group.name).lower() + '_t'
  return re.sub('(_mask)?_t$', '_mask_t', enumname)

def toFunctionName(v):
  tmp = v[2:] if v.startswith('gl') else v
  return _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', tmp).lower()

def getTypeString(param):
  def typeNameToUse():
    if param.group:
      enumName = getGroupEnumName(param.group)
      if param.type == 'GLbitfield':
        return 'gl::bitmask<%s>' % enumName
      return enumName
    return toTypeName(param.baseType)

  newTypename = typeNameToUse()

  return param.type.replace(param.baseType, newTypename)

def getBaseTypeString(param):
  def typeNameToUse():
    if param.group:
      enumName = getGroupEnumName(param.group)
      return enumName
    return toTypeName(param.baseType)

  newTypename = typeNameToUse()

  return newTypename

#
# serialisation procedures
#

def _compileParameter(param):
  typename = getTypeString(param)
  vars = {'type': typename, 'name': param.name}
  return compileTemplate(COMMAND_PARAMETER_TEMPLATE, vars)

def _compileArgument(param):
  paramName = 'reinterpret_cast<%s>(%s)' % (param.type, param.name) if param.isPointer and param.group or param.isStruct else param.name
  shouldCast = param.group and not param.isPointer and not param.isStruct
  if shouldCast:
    if param.type == 'GLbitfield':
      paramName = paramName + '.value' 
    return 'static_cast<%s>(%s)' % (param.type, paramName)
  return paramName

def writeCppEnums(groups, fp, namespaces, headers, headerGuard):
  GROUPS_TO_IGNORE = ['Boolean']

  def compileEnum(enum):
    def toEnumValue(v):
      reserved_words = ['return', 'bool', 'true', 'false', 'byte', 'long', 'int', 'short', 'char', 'float', 'double', 'unsigned_byte', 'unsigned_short', 'unsigned_int', 'and', 'or', 'xor', 'not']
      val = v[3:] if v.startswith('GL_') else v
      val = val.lower()
      val = val + '_' if val in reserved_words else val
      val = '_' + val if val[0].isdigit() else val
      return val
    vars = {'name' : toEnumValue(enum.name), 'value': enum.value}
    return compileTemplate(ENUM_VALUE_TEMPLATE, vars)

  # todo: incorporate 'bitmask' tag from enum collection?
  def compileGroup(group):
    content = ''.join([compileEnum(e) for e in sorted(group.enums, key=lambda e: (e.value, e.name))])
    vars = group.toDictionary()
    glname = vars['name']
    vars['content'] = content
    vars['name'] = getGroupEnumName(group)
    vars['masktype_name'] = getGroupMasktypeName(group)
    template = BITMASK_ENUM_CLASS_TEMPLATE if group.isBitmask else ENUM_CLASS_TEMPLATE
    return compileTemplate(template, vars)

  content = '\n'.join([compileGroup(g) for g in groups if g.name not in GROUPS_TO_IGNORE])

  vars = {
    'namespaces': namespaces,
    'content': content,
    'header_guard': headerGuard,
    'LOCAL_HEADERS': headers,
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))


def writeCppCommandsHeader(commands, fp, namespaces, headers, headerGuard):
  def compileCommand(command):
    parameters = ', '.join([_compileParameter(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else getGroupEnumName(command.returngroup)
    return compileTemplate(COMMAND_PROTOTYPE_TEMPLATE, vars)

  # content = compileTemplate(GET_CORE_PROC_ADDRESS_DECLARATION_TEMPLATE, {'commands': commands})
  content = '\n'.join([compileCommand(c) for c in commands])

  vars = {
    'namespaces': namespaces,
    'content': content,
    'header_guard': headerGuard,
    'LOCAL_HEADERS': headers,
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))

def writeCppCommandsCpp(commands, fp, namespaces, headers, sysHeaders):
  def compileCommand(command):
    parameters = ', '.join([_compileParameter(p) for p in command.parameters])
    arguments = ', '.join([_compileArgument(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['gl_name'] = vars['name']
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['argument_list'] = arguments
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else getGroupEnumName(command.returngroup)
    vars['maybe_return'] = 'return ' if vars['return_type'] != 'void' else ''
    vars['static_cast_begin'] = 'static_cast<%s>(' % vars['return_type'] if command.returngroup else ''
    vars['static_cast_end'] = ')' if command.returngroup else ''
    vars['params'] = command.parameters
    vars['param_types'] = {p.name: getBaseTypeString(p) for p in command.parameters}
    return compileTemplate(COMMAND_IMPLEMENTATION_TEMPLATE, vars)

  #content = compileTemplate(GET_CORE_PROC_ADDRESS_DEFINITION_TEMPLATE, {'commands': commands})
  content = '\n'.join([compileCommand(c) for c in commands])

  vars = {
    'namespaces': namespaces,
    'content': content,
    'LOCAL_HEADERS': headers,
    'SYSTEM_HEADERS': sysHeaders
  }

  fp.write(compileTemplate(CPP_TEMPLATE, vars))

ALIAS_SECTION_HEADER = """
   /**
    * command aliases
    */
  
"""

EXTENSION_SECTION_HEADER = """
   /**
    * non-aliased commands
    */
  
"""

def _sortCommandsByExtensions(cs):
  def calculateCommandExtensionsHash(c):
    sortedExtensionNames = sorted(list(map(lambda e: e.name, c.extensions)))
    return '-'.join(sortedExtensionNames) + '-' + c.name
  return sorted(cs, key=calculateCommandExtensionsHash)

def writeCppExtCommandsHeader(commands, fp, namespaces, headers, headerGuard):
  def compileCommand(command, extensions, usealias):
    parameters = ', '.join([_compileParameter(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['REQUIRED_EXTENSIONS'] = sorted(extensions, key=lambda e: e.name)
    vars['name'] = toFunctionName(vars['basename']) if usealias else toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else getGroupEnumName(command.returngroup)
    return compileTemplate(EXT_COMMAND_PROTOTYPE_TEMPLATE, vars)

  commandContent = '\n'.join([compileCommand(c, c.extensions, False) for c in _sortCommandsByExtensions(commands)])

  baseCommandNames = {c.name for c in commands if c.name == c.basename}
  commandsByBaseName = {c.basename: c for c in commands if c.name not in baseCommandNames}
  commandsToAlias = commandsByBaseName.values()

  aliasContent = '\n'.join([compileCommand(c, c.extensions, True) for c in _sortCommandsByExtensions(commandsToAlias)])

  content = ALIAS_SECTION_HEADER + aliasContent + '\n' + EXTENSION_SECTION_HEADER + commandContent

  vars = {
    'namespaces': namespaces,
    'content': content,
    'header_guard': headerGuard,
    'LOCAL_HEADERS': headers,
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))

def writeCppExtCommandsCpp(apis, commands, fp, namespaces, headers, sysHeaders):
  def filterExtensions(es):
    # extensions that contribute to any of the given apis
    return [e for e in es if e.apis & apis]

  def compileCommand(command, extensions, usealias):
    parameters = ', '.join([_compileParameter(p) for p in command.parameters])
    arguments = ', '.join([_compileArgument(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['REQUIRED_EXTENSIONS'] = sorted(filterExtensions(extensions), key=lambda e: e.name)
    vars['gl_name'] = vars['name']
    vars['name'] = toFunctionName(vars['basename']) if usealias else toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['argument_list'] = arguments
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else getGroupEnumName(command.returngroup)
    vars['maybe_return'] = 'return ' if vars['return_type'] != 'void' else ''
    vars['static_cast_begin'] = 'static_cast<%s>(' % vars['return_type'] if command.returngroup else ''
    vars['static_cast_end'] = ')' if command.returngroup else ''
    vars['params'] = command.parameters
    vars['param_types'] = {p.name: getBaseTypeString(p) for p in command.parameters}
    return compileTemplate(EXT_COMMAND_IMPLEMENTATION_TEMPLATE, vars)

  commandContent = '\n'.join([compileCommand(c, c.extensions, False) for c in _sortCommandsByExtensions(commands)])

  baseCommandNames = {c.name for c in commands if c.name == c.basename}
  commandsByBaseName = {c.basename: c for c in commands if c.name not in baseCommandNames}
  commandsToAlias = commandsByBaseName.values()

  aliasContent = '\n'.join([compileCommand(c, c.extensions, True) for c in _sortCommandsByExtensions(commandsToAlias)])

  content = ALIAS_SECTION_HEADER + aliasContent + '\n' + EXTENSION_SECTION_HEADER + commandContent

  vars = {
    'namespaces': namespaces,
    'content': content,
    'LOCAL_HEADERS': headers,
    'SYSTEM_HEADERS': sysHeaders
  }

  fp.write(compileTemplate(CPP_TEMPLATE, vars))


def writeCppExtSynthCommandsHeader(synthExtCommandsByBaseCommand, fp, namespaces, headers, headerGuard):
  baseCommands = synthExtCommandsByBaseCommand.keys()

  def compileCommand(command, extensions):
    parameters = ', '.join([_compileParameter(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['REQUIRED_EXTENSIONS'] = extensions
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else getGroupEnumName(command.returngroup)
    return compileTemplate(EXT_COMMAND_PROTOTYPE_TEMPLATE, vars)

  commandsByExtensions = {}
  for c in baseCommands:
    sortedExtensionNames = sorted(list(map(lambda e: e.name, c.extensions)))
    extensionNamesHash = ', '.join(sortedExtensionNames)
    if extensionNamesHash not in commandsByExtensions:
      commandsByExtensions[extensionNamesHash] = []
    commandsByExtensions[extensionNamesHash].append(c)

  sortedCommands = [c for cs in commandsByExtensions.values() for c in cs]

  def derivedExtensionsForCommand(c):
    extensionSets = map(lambda extC: extC.extensions, synthExtCommandsByBaseCommand[c])
    extensions = reduce(lambda a, b: a | b, extensionSets, set())
    return extensions

  content = '\n'.join([compileCommand(c, derivedExtensionsForCommand(c)) for c in sortedCommands])

  vars = {
    'namespaces': namespaces,
    'content': content,
    'header_guard': headerGuard,
    'LOCAL_HEADERS': headers,
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))

def writeCppExtSynthCommandsCpp(synthExtCommandsByBaseCommand, fp, namespaces, headers, sysHeaders):
  baseCommands = synthExtCommandsByBaseCommand.keys()

  def compileCommand(command, extensions):
    parameters = ', '.join([_compileParameter(p) for p in command.parameters])
    arguments = ', '.join([_compileArgument(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['REQUIRED_EXTENSIONS'] = sorted(extensions, key=lambda e: e.name)
    vars['gl_name'] = vars['name']
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['argument_list'] = arguments
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else getGroupEnumName(command.returngroup)
    vars['maybe_return'] = 'return ' if vars['return_type'] != 'void' else ''
    vars['static_cast_begin'] = 'static_cast<%s>(' % vars['return_type'] if command.returngroup else ''
    vars['static_cast_end'] = ')' if command.returngroup else ''
    vars['params'] = command.parameters
    vars['param_types'] = {p.name: getBaseTypeString(p) for p in command.parameters}
    return compileTemplate(EXT_COMMAND_IMPLEMENTATION_TEMPLATE, vars)

  def derivedExtensionsForCommand(c):
    extensionSets = map(lambda extC: extC.extensions, synthExtCommandsByBaseCommand[c])
    extensions = reduce(lambda a, b: a | b, extensionSets, set())
    return extensions

  content = '\n'.join([compileCommand(c, derivedExtensionsForCommand(c)) for c in baseCommands])

  vars = {
    'namespaces': namespaces,
    'content': content,
    'LOCAL_HEADERS': headers,
    'SYSTEM_HEADERS': sysHeaders
  }

  fp.write(compileTemplate(CPP_TEMPLATE, vars))

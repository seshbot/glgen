import json
import time
import sys

#
# json routines
#

PROJECT_NAME = 'glgen'
PROJECT_REPO = 'https://github.com/seshbot/glgen'

JSON_PRELUDE = """\
// This file was autogenerated by %s (%s) on %s
// Command line: %s
""" % (PROJECT_NAME, PROJECT_REPO, time.strftime('%Y-%m-%d'), ' '.join(sys.argv))

def writePreludeToFile(fp):
  fp.write(JSON_PRELUDE)

def writeJson(entities, fp):
  fp.write("[\n")
  for entity in entities:
    data = entity.toDictionary()
    #json.dump(data, fp, indent=2, separators=(',', ': '))
    json.dump(data, fp)
    fp.write(',\n')
  fp.write("]")


#
# C++ routines
#

# template patterns:
#  ${DATE} - generation date
#  ${HEADER_GUARD} - to be used in header guard
#  ${CONTENTS} - entire contents of the file
HEADER_TEMPLATE = """\
/**
 * This file was autogenerated by ${PROJECT_NAME} ${PROJECT_REPO} on ${TIME}
 * Command line: ${COMMANDLINE}
 */
#ifndef ${HEADER_GUARD}__H
#define ${HEADER_GUARD}__H

{{'\\n'.join(['#include <%s>' % h for h in SYSTEM_HEADERS]) if 'SYSTEM_HEADERS' in locals() else ''}}
{{'\\n'.join(['#include "%s"' % h for h in LOCAL_HEADERS]) if 'LOCAL_HEADERS' in locals() else ''}}

namespace gl {
${CONTENT}
} // namespace gl

#endif // #ifndef ${HEADER_GUARD}__H
"""

CPP_TEMPLATE = """\
/**
 * This file was autogenerated by gldoc (https://github.com/seshbot/gldoc) on ${TIME}
 * Command line: ${COMMANDLINE}
 */

{{'\\n'.join(['#include <%s>' % h for h in SYSTEM_HEADERS]) if 'SYSTEM_HEADERS' in locals() else ''}}
{{'\\n'.join(['#include "%s"' % h for h in LOCAL_HEADERS]) if 'LOCAL_HEADERS' in locals() else ''}}

namespace gl {
${CONTENT}
}
"""

ENUM_CLASS_TEMPLATE = """\
  enum class ${NAME} {
${CONTENT}  };
"""

ENUM_VALUE_TEMPLATE = """\
    ${NAME} = ${VALUE},
"""

COMMAND_PARAMETER_TEMPLATE = "${TYPE} ${NAME}"
COMMAND_PROTOTYPE_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST});
"""

COMMAND_IMPLEMENTATION_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST}) {
      {{''.join(['%s %s_; ' % (p.baseType, p.name) for p in params if p.isPointer and p.group])}}
      ${MAYBE_RETURN}${STATIC_CAST_BEGIN}${GL_NAME}(${ARGUMENT_LIST})${STATIC_CAST_END};
      {{''.join(['*%s = static_cast<%s>(%s_); ' % (p.name, param_types[p.name], p.name) for p in params if p.isPointer and p.group])}}
    }
"""

import re

def compileTemplate(template, vars):
  vars['time'] = time.strftime('%Y-%m-%d')
  vars['commandline'] = ' '.join(sys.argv)
  vars['PROJECT_NAME'] = PROJECT_NAME
  vars['PROJECT_REPO'] = PROJECT_REPO
  compiled = template

  # match {{.*}} and capture expression
  eval_expr_pattern = re.compile('{{([^}]*)}}', re.IGNORECASE)

  def evalExpression(match):
    expr = match.group(1)
    return eval(expr, {}, vars)

  compiled = eval_expr_pattern.sub(evalExpression, compiled)

  # match '${.*}' and capture variable name
  subst_var_pattern = re.compile('\${([^}]*)}', re.IGNORECASE)
  lowervars = {name.lower(): val for name, val in vars.iteritems()}

  def substituteVar(match):
    var = match.group(1).lower()
    return lowervars[var] if var in lowervars else match.group()

  return subst_var_pattern.sub(substituteVar, compiled)

#
# name conversion utilities
#

_CAMEL_CASE_TO_SNAKE_CASE_REGEX_ = re.compile('((?<=[a-z])[A-Z0-9]|(?!^)[A-Z](?=[a-z]))')
_TYPE_NAME_REGEX_ = re.compile('(const[ ]+)?([^ *]+)([ ]*\*)?') # (const )(typename)( *)

def toTypeName(v):
  exceptions = {'void'} # do not modify these types

  prevTypename = _TYPE_NAME_REGEX_.match(v).group(2)
  newTypename = prevTypename[2:] if prevTypename.startswith('GL') else prevTypename
  newTypename = newTypename + '_t' if newTypename not in exceptions else newTypename
  return v.replace(prevTypename, newTypename)

def toEnumName(v):
  return _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', v).lower() + '_t'

def toFunctionName(v):
  tmp = v[2:] if v.startswith('gl') else v
  return _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', tmp).lower()

def getTypeString(param):
  newTypename = toEnumName(param.group.name) if param.group else toTypeName(param.baseType)

  return param.type.replace(param.baseType, newTypename)


#
# serialisation procedures
#

def writeCppEnums(groups, fp):
  def compileEnum(enum):
    def toEnumValue(v):
      reserved_words = ['return', 'bool', 'true', 'false', 'byte', 'long', 'int', 'short', 'char', 'float', 'double', 'unsigned_byte', 'unsigned_short', 'unsigned_int']
      val = v[3:] if v.startswith('GL_') else v
      val = val.lower()
      val = val + '_' if val in reserved_words else val
      return val
    vars = {'name' : toEnumValue(enum.name), 'value': enum.value}
    return compileTemplate(ENUM_VALUE_TEMPLATE, vars)

  # todo: incorporate 'bitmask' tag from enum collection?
  def compileGroup(group):
    content = ''.join([compileEnum(e) for e in sorted(group.enums, key=lambda e: e.value)])
    vars = group.toDictionary()
    vars['content'] = content
    vars['name'] = toEnumName(vars['name'])
    return compileTemplate(ENUM_CLASS_TEMPLATE, vars)

  content = '\n'.join([compileGroup(g) for g in groups])

  vars = {
    'content': content,
    'header_guard': 'ENUMS',
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))


def writeCppCommandsHeader(commands, fp):
  def compileParameter(param):
    typename = getTypeString(param)
    vars = {'type': typename, 'name': param.name}
    return compileTemplate(COMMAND_PARAMETER_TEMPLATE, vars)

  def compileCommand(command):
    parameters = ', '.join([compileParameter(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else toEnumName(command.returngroup.name)
    return compileTemplate(COMMAND_PROTOTYPE_TEMPLATE, vars)

  content = '\n'.join([compileCommand(c) for c in commands])

  vars = {
    'content': content,
    'header_guard': 'COMMANDS',
    'LOCAL_HEADERS': ['enums.h', 'types.h'],
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))

def writeCppCommandsCpp(commands, fp):
  def compileParameter(param):
    typename = getTypeString(param)
    vars = {'type': typename, 'name': param.name}
    return compileTemplate(COMMAND_PARAMETER_TEMPLATE, vars)
  def compileArgument(param):
    paramName = '&%s_' % param.name if param.isPointer and param.group else param.name
    shouldCast = param.group and not param.isPointer
    return paramName if not shouldCast else 'static_cast<%s>(%s)' % (param.type, paramName)

  def compileCommand(command):
    parameters = ', '.join([compileParameter(p) for p in command.parameters])
    arguments = ', '.join([compileArgument(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['gl_name'] = vars['name']
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    vars['argument_list'] = arguments
    vars['return_type'] = toTypeName(command.returntype) if not command.returngroup else toEnumName(command.returngroup.name)
    vars['maybe_return'] = 'return ' if vars['return_type'] != 'void' else ''
    vars['static_cast_begin'] = 'static_cast<%s>(' % vars['return_type'] if command.returngroup else ''
    vars['static_cast_end'] = ')' if command.returngroup else ''
    vars['params'] = command.parameters
    vars['param_types'] = {p.name: toTypeName(p.baseType) for p in command.parameters}
    return compileTemplate(COMMAND_IMPLEMENTATION_TEMPLATE, vars)

  content = '\n'.join([compileCommand(c) for c in commands])

  vars = {
    'content': content,
    'LOCAL_HEADERS': ['commands.h'],
    'SYSTEM_HEADERS': ['GLES2/gl2.h']
  }

  fp.write(compileTemplate(CPP_TEMPLATE, vars))

import json
import time
import sys

#
# json routines
#

PROJECT_NAME = 'glgen'
PROJECT_REPO = 'https://github.com/seshbot/glgen'

JSON_PRELUDE = """\
// This file was autogenerated by %s (%s) on %s
// Command line: %s
""" % (PROJECT_NAME, PROJECT_REPO, time.strftime('%Y-%m-%d'), ' '.join(sys.argv))

def writePreludeToFile(fp):
  fp.write(JSON_PRELUDE)

def writeJson(entities, fp):
  fp.write("[\n")
  for entity in entities:
    data = entity.toDictionary()
    #json.dump(data, fp, indent=2, separators=(',', ': '))
    json.dump(data, fp)
    fp.write(',\n')
  fp.write("]")


#
# C++ routines
#

# template patterns:
#  ${DATE} - generation date
#  ${HEADER_GUARD} - to be used in header guard
#  ${CONTENTS} - entire contents of the file
HEADER_TEMPLATE = """\
/**
 * This file was autogenerated by ${PROJECT_NAME} ${PROJECT_REPO} on ${TIME}
 * Command line: ${COMMANDLINE}
 */
#ifndef ${HEADER_GUARD}__H
#define ${HEADER_GUARD}__H

{{'\\n'.join(['#include <%s>' % h for h in SYSTEM_HEADERS]) if 'SYSTEM_HEADERS' in locals() else ''}}
{{'\\n'.join(['#include "%s"' % h for h in LOCAL_HEADERS]) if 'LOCAL_HEADERS' in locals() else ''}}

namespace gl {
${CONTENT}
} // namespace gl

#endif // #ifndef ${HEADER_GUARD}__H
"""

CPP_TEMPLATE = """\
/**
 * This file was autogenerated by gldoc (https://github.com/seshbot/gldoc) on ${TIME}
 * Command line: ${COMMANDLINE}
 */

{{'\\n'.join(['#include <%s>' % h for h in SYSTEM_HEADERS]) if 'SYSTEM_HEADERS' in locals() else ''}}
{{'\\n'.join(['#include "%s"' % h for h in LOCAL_HEADERS]) if 'LOCAL_HEADERS' in locals() else ''}}

namespace gl {
${CONTENT}
}
"""

ENUM_CLASS_TEMPLATE = """\
  enum class ${NAME} {
${CONTENT}  };
"""

ENUM_VALUE_TEMPLATE = """\
    ${NAME} = ${VALUE},
"""

COMMAND_PARAMETER_TEMPLATE = "${TYPE} ${NAME}"
COMMAND_PROTOTYPE_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST});
"""

COMMAND_IMPLEMENTATION_TEMPLATE = """\
    ${RETURN_TYPE} ${NAME}(${PARAMETER_LIST}) {
    }
"""

import re

def compileTemplate(template, vars):
  vars['time'] = time.strftime('%Y-%m-%d')
  vars['commandline'] = ' '.join(sys.argv)
  vars['PROJECT_NAME'] = PROJECT_NAME
  vars['PROJECT_REPO'] = PROJECT_REPO
  compiled = template

  # match {{.*}} and capture expression
  eval_expr_pattern = re.compile('{{([^}]*)}}', re.IGNORECASE)

  def evalExpression(match):
    expr = match.group(1)
    return eval(expr, {}, vars)

  compiled = eval_expr_pattern.sub(evalExpression, compiled)

  # match '${.*}' and capture variable name
  subst_var_pattern = re.compile('\${([^}]*)}', re.IGNORECASE)
  lowervars = {name.lower(): val for name, val in vars.iteritems()}

  def substituteVar(match):
    var = match.group(1).lower()
    return lowervars[var] if var in lowervars else match.group()

  return subst_var_pattern.sub(substituteVar, compiled)

_CAMEL_CASE_TO_SNAKE_CASE_REGEX_ = re.compile('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))')
def toEnumName(v):
  return _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', v).lower()
def toFunctionName(v):
  tmp = v[2:] if v.startswith('gl') else v
  return _CAMEL_CASE_TO_SNAKE_CASE_REGEX_.sub(r'_\1', tmp).lower()

def writeCppEnums(groups, fp):
  def compileEnum(enum):
    def toEnumValue(v):
      reserved_words = ['return', 'true', 'false', 'byte', 'long', 'int', 'short', 'char', 'float', 'double', 'unsigned_byte', 'unsigned_short', 'unsigned_int']
      val = v[3:] if v.startswith('GL_') else v
      val = val.lower()
      val = val + '_' if val in reserved_words else val
      return val
    vars = {'name' : toEnumValue(enum.name), 'value': enum.value}
    return compileTemplate(ENUM_VALUE_TEMPLATE, vars)

  # todo: incorporate 'bitmask' tag from enum collection?
  def compileGroup(group):
    content = ''.join([compileEnum(e) for e in sorted(group.enums, key=lambda e: e.value)])
    vars = group.toDictionary()
    vars['content'] = content
    vars['name'] = toEnumName(vars['name'])
    return compileTemplate(ENUM_CLASS_TEMPLATE, vars)

  content = '\n'.join([compileGroup(g) for g in groups])

  vars = {
    'content': content,
    'header_guard': 'ENUMS',
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))

def writeCppCommandsHeader(commands, fp):
  def compileParameter(param):
    typename = param.type if not param.group else toEnumName(param.group.name)
    vars = {'type': typename, 'name': param.name}
    return compileTemplate(COMMAND_PARAMETER_TEMPLATE, vars)

  def compileCommand(command):
    parameters = ', '.join([compileParameter(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['name'] = toFunctionName(vars['name'])
    vars['parameter_list'] = parameters
    return compileTemplate(COMMAND_PROTOTYPE_TEMPLATE, vars)

  content = '\n'.join([compileCommand(c) for c in commands])

  vars = {
    'content': content,
    'header_guard': 'COMMANDS',
    'LOCAL_HEADERS': ['enums.h', 'types.h'],
  }

  fp.write(compileTemplate(HEADER_TEMPLATE, vars))

def writeCppCommandsCpp(commands, fp):
  def compileParameter(param):
    typename = param.type if not param.group else param.group.name
    vars = {'type': typename, 'name': param.name}
    return compileTemplate(COMMAND_PARAMETER_TEMPLATE, vars)

  def compileCommand(command):
    parameters = ', '.join([compileParameter(p) for p in command.parameters])
    vars = command.toDictionary()
    vars['parameter_list'] = parameters
    return compileTemplate(COMMAND_IMPLEMENTATION_TEMPLATE, vars)

  content = '\n'.join([compileCommand(c) for c in commands])

  vars = {'content': content, 'LOCAL_HEADERS': ['commands.h']}

  fp.write(compileTemplate(CPP_TEMPLATE, vars))
